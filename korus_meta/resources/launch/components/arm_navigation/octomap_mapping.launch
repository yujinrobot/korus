<!-- Launch octomap_server for mapping: Listens to incoming PointCloud2 data 
and incrementally builds an octomap. The data is sent out in different representations. -->
<launch>
	<node pkg="nodelet" type="nodelet" name="pointcloud_throttle_service" args="load pointcloud_throttle_service/PointCloudThrottleServiceNodelet /sensor_3d_nodelet_manager" respawn="false">
	  <param name="start_publishing_on_startup" type="bool" value="true" />
	  <remap from="pointcloud_throttle_service/pointcloud_in" to="selffiltered_pointcloud" />
	</node>
	<node pkg="nodelet" type="nodelet" name="octomap_server" args="load octomap_server/OctomapServerNodelet /sensor_3d_nodelet_manager" respawn="false">
	    <param name="resolution" value="0.03" />
	    
	    <!-- fixed map frame (set to 'map' if SLAM or localization running!) -->
	  <param name="frame_id" type="string" value="/base_footprint" />
	  
	  <!-- maximum range to integrate (speedup!) -->
	  <param name="sensor_model/max_range" value="3.0" />
	  <!-- Probabilities for hits and misses in the sensor model when dynamically building a map -->
	  <param name="sensor_model/hit" value="1.0" /> <!-- default: 0.7 -->
	   <!-- kind of how many nothing has been there until collision object gets removed -->
	  <param name="sensor_model/miss" value="0.0" /> <!-- default: 0.4 -->
	   
	  <!-- data source to integrate (PointCloud2) -->
	   <remap from="octomap_server/cloud_in" to="pointcloud_throttle_service/throttled_pointcloud_out" />
<!--      <remap from="octomap_server/cloud_in" to="/selffiltered_pointcloud" /> -->
	   <remap from="octomap_server/collision_map_out" to="collision_map_occ" />
	</node>
</launch>